import scipy.integrate as spi
import numpy as np
import matplotlib.pyplot as plt
import random as rd
import networkx as nx


# import itertools


def create_direct_graph(nodes):
    max_iter_num = 100  # number of iterations

    for node in G:
        G.add_node(node, state=0)  # Identify the state with state state=0 not infected, state=1 infected

    all_infect_nodes = [i_1, i_2, i_3, i_4]  # All infected nodes are placed here
    res = [[i_1, i_2, i_3, i_4]]
    all_suscept_nodes = list(G)
    sus = [[]]
    a = 0
    plt.rcParams['figure.figsize'] = (12, 9)
    nx.draw(G, pos, with_labels=True, node_color='b', node_size=50, node_shape='.')
    for ri in range(len(res)):
        nx.draw_networkx_nodes(G, pos, node_color='b', node_size=50, nodelist=sus[ri])
        nx.draw_networkx_nodes(G, pos, node_color='red', node_size=50, nodelist=res[ri])
    plt.show()
    for i in range(max_iter_num):
        # new_infect = list()  # Newly infected
        for v in all_infect_nodes:
            for nbr in G.neighbors(v):
                # if nbr not in all_suscept_nodes:
                if G.nodes[nbr]['state'] == 0:  # If this neighbor node is not infected and not cured
                    # for edge in G.edges:
                    #     G.add_edge(edge[0], edge[1], weight=rd.uniform(0, 1))  # Can it be used as a weight? Virus infection ability
                    # edge_data = G.get_edge_data(v, nbr)
                    if lamb > rd.uniform(0, 1):
                        G.nodes[nbr]['state'] = 1
                        if nbr not in all_infect_nodes:
                            all_infect_nodes.append(nbr)
                        if nbr in all_suscept_nodes:
                            all_suscept_nodes.remove(nbr)
                        # infected_graph.add_edge(v, nbr)
                elif G.nodes[nbr]['state'] == 1:  # If this neighbor node is infected
                    # for edge in G.edges:
                    #     G.add_edge(edge[0], edge[1], weight=rd.uniform(0, 1))
                    # edge_data = G.get_edge_data(v, nbr)
                    if mu > rd.uniform(0, 1):
                        G.nodes[nbr]['state'] = 0
                        if nbr not in all_suscept_nodes:
                            all_suscept_nodes.append(nbr)
                        if nbr in all_infect_nodes:
                            all_infect_nodes.remove(nbr)

            for asn in all_suscept_nodes:
                if asn in all_infect_nodes:
                    all_suscept_nodes.remove(asn)

        all_infect_nodes = list(set(all_infect_nodes))
        print('all_infective_nodes:', all_infect_nodes)

        res.append(all_infect_nodes)
        sus.append(all_suscept_nodes)
        all_suscept_nodes = list(set(all_suscept_nodes))
        print('all_susceptible_nodes:', all_suscept_nodes)

        plt.rcParams['figure.figsize'] = (12, 9)
        nx.draw(G, pos, with_labels=True, node_color='b', node_size=50, node_shape='.')
        for nr in range(len(res)):
            nx.draw_networkx_nodes(G, pos, node_color='b', node_size=50, nodelist=sus[nr])
            nx.draw_networkx_nodes(G, pos, node_color='red', node_size=50, nodelist=res[nr])
        plt.show()

        a += len(all_infect_nodes)
        t1 = '%s time' % i + ' %s nodes' % len(all_infect_nodes)
        print(t1)  # How many nodes are currently infected

    longest = 0
    for value in res:
        longest = max(longest, len(value))
    minimal = 4
    mean = a / 100
    print("max:", longest, '\n' "min:", minimal, '\n' "mean:", mean)
    return G


def create_matrix(dg):
    """
    Generate adjacency matrix
    :param dg: Directed graph
    :return: Adjacency matrix
    """
    return nx.to_numpy_matrix(dg)


# G = nx.barabasi_albert_graph(200, 1, seed=666)
G = nx.star_graph(100)

k = nx.degree(G)
print(k)
pos = nx.spring_layout(G, seed=666)
nodes = np.arange(0, 100, 1)

n = len(nodes)
lamb = 0.3
mu = 0.1
t_range = np.arange(0, 100, 1)
i = np.zeros(n)
i_1 = rd.randint(0, n - 1)
i_2 = rd.randint(0, n - 1)
i_3 = rd.randint(0, n - 1)
i_4 = rd.randint(0, n - 1)  # Select 4 nodes as the source of infection
G.nodes[i_1]['state'] = 1
G.nodes[i_2]['state'] = 1
G.nodes[i_3]['state'] = 1
G.nodes[i_4]['state'] = 1
dg = create_direct_graph(nodes)
adj = create_matrix(dg)
# while i_1 == i_2:
#     i_2 = rd.randint(0, n - 1)
i[i_1] = 1
i[i_2] = 1
i[i_3] = 1
i[i_4] = 1


def sis_i(i, t):
    """
    :param i: infectious(vector)
    :param t: Number of iterations(time)
    :return i: The infection of the node at each moment
    """
    I = np.zeros(n)

    for j in range(n):
        # Calculate the infection situation of each node's neighbors
        neighbor = 0
        for k in range(n):
            neighbor += adj[j, k] * i[k]
        I[j] = (1 - i[j]) * lamb * neighbor - mu * i[j]

    return I


def sis_s(s, t):
    """
    :param s: Susceptible(vector)
    :param t: Number of iterations(time)
    :return i: The susceptibility of the node at each moment
    """
    S = np.zeros(n)

    for j in range(n):
        # Calculate the infection situation of each node's neighbors
        neighbor = 0
        for k in range(n):
            neighbor += adj[j, k] * (1 - s[k])
        S[j] = -s[j] * lamb * neighbor + mu * (1 - s[j])

    return S


def calc_ODE():
    """
    Calculate the differential equation
    """
    result_1 = spi.odeint(func=sis_i, y0=i, t=t_range)
    result_1_mean = np.mean(result_1, axis=1)
    result_2 = spi.odeint(func=sis_s, y0=1 - i, t=t_range)
    result_2_mean = np.mean(result_2, axis=1)
    draw_result(result_1_mean, result_2_mean)


def draw_result(result_1_mean, result_2_mean):
    """
    Draw SIS curve
    """
    plt.plot(t_range, result_1_mean, color="blue")
    plt.plot(t_range, result_2_mean, color="orange")
    # plt.scatter(20, 0.55)
    plt.xlabel("time")
    plt.ylabel("Proportion")
    plt.show()


if __name__ == '__main__':
    calc_ODE()
